{"version":3,"file":"avmHelpers.js","sourceRoot":"","sources":["../src/avmHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CallResultsArray, InterpreterResult, CallRequest, RunParameters } from './types';\n\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\n\n/**\n * Serializes AVM arguments in JSON string which can be passed into marine-js\n * @param initPeerId - peer ID which initialized particle\n * @param currentPeerId - peer ID which is currently executing the particle\n * @param air - particle's air script as string\n * @param prevData - particle's prev data as raw byte array\n * @param data - particle's data as raw byte array\n * @param callResults - array of tuples [callResultKey, callResult]\n * @returns AVM call arguments as serialized JSON string\n */\nexport function serializeAvmArgs(\n    runParams: RunParameters,\n    air: string,\n    prevData: Uint8Array,\n    data: Uint8Array,\n    callResults: CallResultsArray,\n): string {\n    const callResultsToPass: any = {};\n    for (let [key, callResult] of callResults) {\n        callResultsToPass[key] = {\n            ret_code: callResult.retCode,\n            result: callResult.result,\n        };\n    }\n\n    const encoded = encoder.encode(JSON.stringify(callResultsToPass));\n\n    const avmArg = JSON.stringify([\n        // force new line\n        air,\n        Array.from(prevData),\n        Array.from(data),\n        {\n            init_peer_id: runParams.initPeerId,\n            current_peer_id: runParams.currentPeerId,\n            timestamp: runParams.timestamp,\n            ttl: runParams.ttl,\n        },\n        Array.from(encoded),\n    ]);\n\n    return avmArg;\n}\n\n/**\n * Deserializes raw result of AVM call obtained from marine-js into structured form\n * @param rawResult - string containing raw result of AVM call\n * @returns structured InterpreterResult\n */\nexport function deserializeAvmResult(rawResult: string): InterpreterResult {\n    let result: any;\n    try {\n        result = JSON.parse(rawResult);\n    } catch (ex) {\n        throw 'call_module result parsing error: ' + ex + ', original text: ' + rawResult;\n    }\n\n    if (result.error !== '') {\n        throw 'call_module returned error: ' + result.error;\n    }\n\n    result = result.result;\n\n    const callRequestsStr = decoder.decode(new Uint8Array(result.call_requests));\n    let parsedCallRequests;\n    try {\n        if (callRequestsStr.length === 0) {\n            parsedCallRequests = {};\n        } else {\n            parsedCallRequests = JSON.parse(callRequestsStr);\n        }\n    } catch (e) {\n        throw \"Couldn't parse call requests: \" + e + '. Original string is: ' + callRequestsStr;\n    }\n\n    let resultCallRequests: Array<[key: number, callRequest: CallRequest]> = [];\n    for (const key in parsedCallRequests) {\n        const callRequest = parsedCallRequests[key];\n\n        let arguments_;\n        let tetraplets;\n        try {\n            arguments_ = JSON.parse(callRequest.arguments);\n        } catch (e) {\n            throw \"Couldn't parse arguments: \" + e + '. Original string is: ' + arguments_;\n        }\n\n        try {\n            tetraplets = JSON.parse(callRequest.tetraplets);\n        } catch (e) {\n            throw \"Couldn't parse tetraplets: \" + e + '. Original string is: ' + tetraplets;\n        }\n\n        resultCallRequests.push([\n            key as any,\n            {\n                serviceId: callRequest.service_id,\n                functionName: callRequest.function_name,\n                arguments: arguments_,\n                tetraplets: tetraplets,\n            },\n        ]);\n    }\n    return {\n        retCode: result.ret_code,\n        errorMessage: result.error_message,\n        data: result.data,\n        nextPeerPks: result.next_peer_pks,\n        callRequests: resultCallRequests,\n    };\n}\n\ntype CallToAvm = ((args: string) => Promise<string>) | ((args: string) => string);\n\n/**\n * Utility function which serializes AVM args and passed them into AVM returning interpreter result.\n * Call to AVM is delegated to a function which must be provided by user.\n * It might be either synchronous or asynchronous (returning a promise)\n * @param fn - delegated call to AVM\n * @param initPeerId - peer ID which initialized particle\n * @param currentPeerId - peer ID which is currently executing the particle\n * @param air - particle's air script as string\n * @param prevData - particle's prev data as raw byte array\n * @param data - particle's data as raw byte array\n * @param callResults - array of tuples [callResultKey, callResult]\n * @returns structured InterpreterResult\n */\nexport async function callAvm(\n    fn: CallToAvm,\n    runParams: RunParameters,\n    air: string,\n    prevData: Uint8Array,\n    data: Uint8Array,\n    callResults: CallResultsArray,\n): Promise<InterpreterResult> {\n    try {\n        const avmArg = serializeAvmArgs(runParams, air, prevData, data, callResults);\n        const rawResult = await fn(avmArg);\n        return deserializeAvmResult(rawResult);\n    } catch (e) {\n        return {\n            retCode: -1,\n            errorMessage: 'marine-js call failed, ' + e,\n        } as any;\n    }\n}\n"]}
{"version":3,"file":"FluenceConnection.js","sourceRoot":"","sources":["../../src/internal/FluenceConnection.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// @ts-ignore\nimport Websockets from 'libp2p-websockets';\n// @ts-ignore\nimport Mplex from 'libp2p-mplex';\nimport Lib2p2Peer from 'libp2p';\nimport { decode, encode } from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport * as log from 'loglevel';\nimport { Noise } from '@chainsafe/libp2p-noise';\nimport PeerId from 'peer-id';\nimport type { MultiaddrInput } from 'multiaddr';\nimport { Multiaddr } from 'multiaddr';\n// @ts-ignore\nimport { all as allow_all } from 'libp2p-websockets/src/filters';\nimport { Connection } from 'libp2p-interfaces/src/topology';\nimport Buffer from './Buffer';\nimport { PeerIdB58 } from './commonTypes';\n\nexport const PROTOCOL_NAME = '/fluence/particle/2.0.0';\n\n/**\n * Options to configure fluence connection\n */\nexport interface FluenceConnectionOptions {\n    /**\n     * Peer id of the Fluence Peer\n     */\n    peerId: PeerId;\n\n    /**\n     * Multiaddress of the relay to make connection to\n     */\n    relayAddress: MultiaddrInput;\n\n    /**\n     * The dialing timeout in milliseconds\n     */\n    dialTimeoutMs?: number;\n}\n\nexport type ParticleHandler = (particle: string) => void;\n\n/**\n * Base class for connectivity layer to Fluence Network\n */\nexport abstract class FluenceConnection {\n    abstract readonly relayPeerId: PeerIdB58 | null;\n    abstract connect(onIncomingParticle: ParticleHandler): Promise<void>;\n    abstract disconnect(): Promise<void>;\n    abstract sendParticle(nextPeerIds: PeerIdB58[], particle: string): Promise<void>;\n}\n\n/**\n * Implementation for JS peers which connects to Fluence through relay node\n */\nexport class RelayConnection extends FluenceConnection {\n    constructor(\n        public peerId: PeerIdB58,\n        private _lib2p2Peer: Lib2p2Peer,\n        private _relayAddress: Multiaddr,\n        public readonly relayPeerId: PeerIdB58,\n    ) {\n        super();\n    }\n\n    private _connection?: Connection;\n\n    static async createConnection(options: FluenceConnectionOptions): Promise<RelayConnection> {\n        const transportKey = Websockets.prototype[Symbol.toStringTag];\n        const lib2p2Peer = await Lib2p2Peer.create({\n            peerId: options.peerId,\n            modules: {\n                transport: [Websockets],\n                streamMuxer: [Mplex],\n                connEncryption: [new Noise()],\n            },\n            config: {\n                transport: {\n                    [transportKey]: {\n                        filter: allow_all,\n                    },\n                },\n            },\n            dialer: {\n                dialTimeout: options?.dialTimeoutMs,\n            },\n        });\n\n        const relayMultiaddr = new Multiaddr(options.relayAddress);\n        const relayPeerId = relayMultiaddr.getPeerId();\n        if (relayPeerId === null) {\n            throw new Error('Specified multiaddr is invalid or missing peer id: ' + options.relayAddress);\n        }\n\n        return new RelayConnection(\n            // force new line\n            options.peerId.toB58String(),\n            lib2p2Peer,\n            relayMultiaddr,\n            relayPeerId,\n        );\n    }\n\n    async disconnect() {\n        await this._lib2p2Peer.unhandle(PROTOCOL_NAME);\n        await this._lib2p2Peer.stop();\n    }\n\n    async sendParticle(nextPeerIds: PeerIdB58[], particle: string): Promise<void> {\n        if (nextPeerIds.length !== 1 && nextPeerIds[0] !== this.relayPeerId) {\n            throw new Error(\n                `Relay connection only accepts peer id of the connected relay. Got: ${JSON.stringify(\n                    nextPeerIds,\n                )} instead.`,\n            );\n        }\n\n        /*\n        TODO:: find out why this doesn't work and a new connection has to be established each time\n        if (this._connection.streams.length !== 1) {\n            throw new Error('Incorrect number of streams in FluenceConnection');\n        }\n\n        const sink = this._connection.streams[0].sink;\n        */\n\n        const conn = await this._lib2p2Peer.dialProtocol(this._relayAddress, PROTOCOL_NAME);\n        const sink = conn.stream.sink;\n\n        pipe(\n            // force new line\n            [Buffer.from(particle, 'utf8')],\n            encode(),\n            sink,\n        );\n    }\n\n    async connect(onIncomingParticle: ParticleHandler) {\n        await this._lib2p2Peer.start();\n\n        this._lib2p2Peer.handle([PROTOCOL_NAME], async ({ connection, stream }) => {\n            pipe(\n                stream.source,\n                // @ts-ignore\n                decode(),\n                async (source: AsyncIterable<string>) => {\n                    try {\n                        for await (const msg of source) {\n                            try {\n                                onIncomingParticle(msg);\n                            } catch (e) {\n                                log.error('error on handling a new incoming message: ' + e);\n                            }\n                        }\n                    } catch (e) {\n                        log.debug('connection closed: ' + e);\n                    }\n                },\n            );\n        });\n\n        log.debug(`dialing to the node with client's address: ` + this._lib2p2Peer.peerId.toB58String());\n\n        try {\n            this._connection = await this._lib2p2Peer.dial(this._relayAddress);\n        } catch (e: any) {\n            if (e.name === 'AggregateError' && e._errors?.length === 1) {\n                const error = e._errors[0];\n                throw new Error(`Error dialing node ${this._relayAddress}:\\n${error.code}\\n${error.message}`);\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n"]}
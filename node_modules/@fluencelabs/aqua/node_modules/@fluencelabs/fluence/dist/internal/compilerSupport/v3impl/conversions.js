"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.responseServiceValue2ts = exports.returnType2Aqua = exports.ts2aqua = exports.aquaArgs2Ts = exports.aqua2ts = void 0;
var utils_1 = require("../../utils");
var ts_pattern_1 = require("ts-pattern");
/**
 * Convert value from its representation in aqua language to representation in typescript
 * @param value - value as represented in aqua
 * @param type - definition of the aqua type
 * @returns value represented in typescript
 */
var aqua2ts = function (value, type) {
    var res = (0, ts_pattern_1.match)(type)
        .with({ tag: 'nil' }, function () {
        return null;
    })
        .with({ tag: 'option' }, function (opt) {
        if (value.length === 0) {
            return null;
        }
        else {
            return (0, exports.aqua2ts)(value[0], opt.type);
        }
    })
        .with({ tag: 'scalar' }, { tag: 'bottomType' }, { tag: 'topType' }, function () {
        return value;
    })
        .with({ tag: 'array' }, function (arr) {
        return value.map(function (y) { return (0, exports.aqua2ts)(y, arr.type); });
    })
        .with({ tag: 'struct' }, function (x) {
        return Object.entries(x.fields).reduce(function (agg, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], type = _c[1];
            var val = (0, exports.aqua2ts)(value[key], type);
            return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));
        }, {});
    })
        .with({ tag: 'labeledProduct' }, function (x) {
        return Object.entries(x.fields).reduce(function (agg, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], type = _c[1];
            var val = (0, exports.aqua2ts)(value[key], type);
            return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));
        }, {});
    })
        .with({ tag: 'unlabeledProduct' }, function (x) {
        return x.items.map(function (type, index) {
            return (0, exports.aqua2ts)(value[index], type);
        });
    })
        // uncomment to check that every pattern in matched
        // .exhaustive();
        .otherwise(function () {
        throw new Error('Unexpected tag: ' + (0, utils_1.jsonify)(type));
    });
    return res;
};
exports.aqua2ts = aqua2ts;
/**
 * Convert call service arguments list from their aqua representation to representation in typescript
 * @param req - call service data
 * @param arrow - aqua type definition
 * @returns arguments in typescript representation
 */
var aquaArgs2Ts = function (req, arrow) {
    var argTypes = (0, ts_pattern_1.match)(arrow.domain)
        .with({ tag: 'labeledProduct' }, function (x) {
        return Object.values(x.fields);
    })
        .with({ tag: 'unlabeledProduct' }, function (x) {
        return x.items;
    })
        .with({ tag: 'nil' }, function (x) {
        return [];
    })
        // uncomment to check that every pattern in matched
        // .exhaustive()
        .otherwise(function () {
        throw new Error('Unexpected tag: ' + (0, utils_1.jsonify)(arrow.domain));
    });
    if (req.args.length !== argTypes.length) {
        throw new Error("incorrect number of arguments, expected: ".concat(argTypes.length, ", got: ").concat(req.args.length));
    }
    return req.args.map(function (arg, index) {
        return (0, exports.aqua2ts)(arg, argTypes[index]);
    });
};
exports.aquaArgs2Ts = aquaArgs2Ts;
/**
 * Convert value from its typescript representation to representation in aqua
 * @param value - the value as represented in typescript
 * @param type - definition of the aqua type
 * @returns value represented in aqua
 */
var ts2aqua = function (value, type) {
    var res = (0, ts_pattern_1.match)(type)
        .with({ tag: 'nil' }, function () {
        return null;
    })
        .with({ tag: 'option' }, function (opt) {
        if (value === null || value === undefined) {
            return [];
        }
        else {
            return [(0, exports.ts2aqua)(value, opt.type)];
        }
    })
        .with({ tag: 'scalar' }, { tag: 'bottomType' }, { tag: 'topType' }, function () {
        return value;
    })
        .with({ tag: 'array' }, function (arr) {
        return value.map(function (y) { return (0, exports.ts2aqua)(y, arr.type); });
    })
        .with({ tag: 'struct' }, function (x) {
        return Object.entries(x.fields).reduce(function (agg, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], type = _c[1];
            var val = (0, exports.ts2aqua)(value[key], type);
            return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));
        }, {});
    })
        .with({ tag: 'labeledProduct' }, function (x) {
        return Object.entries(x.fields).reduce(function (agg, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], type = _c[1];
            var val = (0, exports.ts2aqua)(value[key], type);
            return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));
        }, {});
    })
        .with({ tag: 'unlabeledProduct' }, function (x) {
        return x.items.map(function (type, index) {
            return (0, exports.ts2aqua)(value[index], type);
        });
    })
        // uncomment to check that every pattern in matched
        // .exhaustive()
        .otherwise(function () {
        throw new Error('Unexpected tag: ' + (0, utils_1.jsonify)(type));
    });
    return res;
};
exports.ts2aqua = ts2aqua;
/**
 * Convert return type of the service from it's typescript representation to representation in aqua
 * @param returnValue - the value as represented in typescript
 * @param arrowType - the arrow type which describes the service
 * @returns - value represented in aqua
 */
var returnType2Aqua = function (returnValue, arrowType) {
    if (arrowType.codomain.tag === 'nil') {
        return {};
    }
    if (arrowType.codomain.items.length === 0) {
        return {};
    }
    if (arrowType.codomain.items.length === 1) {
        return (0, exports.ts2aqua)(returnValue, arrowType.codomain.items[0]);
    }
    return arrowType.codomain.items.map(function (type, index) {
        return (0, exports.ts2aqua)(returnValue[index], type);
    });
};
exports.returnType2Aqua = returnType2Aqua;
/**
 * Converts response value from aqua its representation to representation in typescript
 * @param req - call service data
 * @param arrow - aqua type definition
 * @returns response value in typescript representation
 */
var responseServiceValue2ts = function (req, arrow) {
    return (0, ts_pattern_1.match)(arrow.codomain)
        .with({ tag: 'nil' }, function () {
        return undefined;
    })
        .with({ tag: 'unlabeledProduct' }, function (x) {
        if (x.items.length === 0) {
            return undefined;
        }
        if (x.items.length === 1) {
            return (0, exports.aqua2ts)(req.args[0], x.items[0]);
        }
        return req.args.map(function (y, index) { return (0, exports.aqua2ts)(y, x.items[index]); });
    })
        .exhaustive();
};
exports.responseServiceValue2ts = responseServiceValue2ts;
//# sourceMappingURL=conversions.js.map
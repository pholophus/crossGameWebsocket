"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerService = void 0;
var FluencePeer_1 = require("../../FluencePeer");
var index_1 = require("../../../index");
var services_1 = require("./services");
/**
 * Convenience function to support Aqua `service` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param args - raw arguments passed by user to the generated function
 * @param def - service definition generated by the Aqua compiler
 */
function registerService(args, def) {
    var e_1, _a;
    var _b = extractArgs(args, def.defaultServiceId), peer = _b.peer, service = _b.service, serviceId = _b.serviceId;
    if (!peer.getStatus().isInitialized) {
        throw new Error('Could not register the service because the peer is not initialized. Are you passing the wrong peer to the register function?');
    }
    // Checking for missing keys
    var requiredKeys = def.functions.tag === 'nil' ? [] : Object.keys(def.functions.fields);
    var incorrectServiceDefinitions = requiredKeys.filter(function (f) { return !(f in service); });
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service ".concat(serviceId, ": missing functions: ") +
            incorrectServiceDefinitions.map(function (d) { return "'" + d + "'"; }).join(', '));
    }
    var singleFunctions = def.functions.tag === 'nil' ? [] : Object.entries(def.functions.fields);
    try {
        for (var singleFunctions_1 = __values(singleFunctions), singleFunctions_1_1 = singleFunctions_1.next(); !singleFunctions_1_1.done; singleFunctions_1_1 = singleFunctions_1.next()) {
            var singleFunction = singleFunctions_1_1.value;
            var _c = __read(singleFunction, 2), name_1 = _c[0], type = _c[1];
            // The function has type of (arg1, arg2, arg3, ... , callParams) => CallServiceResultType | void
            // Account for the fact that user service might be defined as a class - .bind(...)
            var userDefinedHandler = service[name_1].bind(service);
            var serviceDescription = (0, services_1.userHandlerService)(serviceId, singleFunction, userDefinedHandler);
            (0, services_1.registerGlobalService)(peer, serviceDescription);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (singleFunctions_1_1 && !singleFunctions_1_1.done && (_a = singleFunctions_1.return)) _a.call(singleFunctions_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.registerService = registerService;
/**
 * Arguments could be passed in one these configurations:
 * [serviceObject]
 * [peer, serviceObject]
 * [defaultId, serviceObject]
 * [peer, defaultId, serviceObject]
 *
 * Where serviceObject is the raw object with function definitions passed by user
 *
 * This function select the appropriate configuration and returns
 * arguments in a structured way of: { peer, serviceId, service }
 */
var extractArgs = function (args, defaultServiceId) {
    var peer;
    var serviceId;
    var service;
    if (FluencePeer_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = index_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = defaultServiceId;
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!FluencePeer_1.FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    return {
        peer: peer,
        serviceId: serviceId,
        service: service,
    };
};
//# sourceMappingURL=registerService.js.map
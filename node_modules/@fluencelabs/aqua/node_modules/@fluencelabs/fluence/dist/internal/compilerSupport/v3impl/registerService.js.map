{"version":3,"file":"registerService.js","sourceRoot":"","sources":["../../../../src/internal/compilerSupport/v3impl/registerService.ts"],"names":[],"mappings":"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","sourcesContent":["import { FluencePeer } from '../../FluencePeer';\nimport { Fluence } from '../../../index';\nimport { ServiceDef } from './interface';\nimport { registerGlobalService, userHandlerService } from './services';\n\n/**\n * Convenience function to support Aqua `service` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param args - raw arguments passed by user to the generated function\n * @param def - service definition generated by the Aqua compiler\n */\nexport function registerService(args: any[], def: ServiceDef) {\n    const { peer, service, serviceId } = extractArgs(args, def.defaultServiceId);\n\n    if (!peer.getStatus().isInitialized) {\n        throw new Error(\n            'Could not register the service because the peer is not initialized. Are you passing the wrong peer to the register function?',\n        );\n    }\n\n    // Checking for missing keys\n    const requiredKeys = def.functions.tag === 'nil' ? [] : Object.keys(def.functions.fields);\n    const incorrectServiceDefinitions = requiredKeys.filter((f) => !(f in service));\n    if (!!incorrectServiceDefinitions.length) {\n        throw new Error(\n            `Error registering service ${serviceId}: missing functions: ` +\n                incorrectServiceDefinitions.map((d) => \"'\" + d + \"'\").join(', '),\n        );\n    }\n\n    const singleFunctions = def.functions.tag === 'nil' ? [] : Object.entries(def.functions.fields);\n    for (let singleFunction of singleFunctions) {\n        let [name, type] = singleFunction;\n        // The function has type of (arg1, arg2, arg3, ... , callParams) => CallServiceResultType | void\n        // Account for the fact that user service might be defined as a class - .bind(...)\n        const userDefinedHandler = service[name].bind(service);\n\n        const serviceDescription = userHandlerService(serviceId, singleFunction, userDefinedHandler);\n        registerGlobalService(peer, serviceDescription);\n    }\n}\n\n/**\n * Arguments could be passed in one these configurations:\n * [serviceObject]\n * [peer, serviceObject]\n * [defaultId, serviceObject]\n * [peer, defaultId, serviceObject]\n *\n * Where serviceObject is the raw object with function definitions passed by user\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, serviceId, service }\n */\nconst extractArgs = (\n    args: any[],\n    defaultServiceId?: string,\n): { peer: FluencePeer; serviceId: string; service: any } => {\n    let peer: FluencePeer;\n    let serviceId: any;\n    let service: any;\n    if (FluencePeer.isInstance(args[0])) {\n        peer = args[0];\n    } else {\n        peer = Fluence.getPeer();\n    }\n\n    if (typeof args[0] === 'string') {\n        serviceId = args[0];\n    } else if (typeof args[1] === 'string') {\n        serviceId = args[1];\n    } else {\n        serviceId = defaultServiceId;\n    }\n\n    // Figuring out which overload is the service.\n    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def\n    // If the first argument is peer, we are checking further. The second argument might either be\n    // an object, that it must be the service object\n    // or a string, which is the service id. In that case the service is the third argument\n    if (!FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {\n        service = args[0];\n    } else if (typeof args[1] === 'object') {\n        service = args[1];\n    } else {\n        service = args[2];\n    }\n\n    return {\n        peer: peer,\n        serviceId: serviceId,\n        service: service,\n    };\n};\n"]}
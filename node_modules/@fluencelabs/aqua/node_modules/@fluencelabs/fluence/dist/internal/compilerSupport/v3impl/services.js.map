{"version":3,"file":"services.js","sourceRoot":"","sources":["../../../../src/internal/compilerSupport/v3impl/services.ts"],"names":[],"mappings":"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","sourcesContent":["import { SecurityTetraplet } from '@fluencelabs/avm';\nimport { match } from 'ts-pattern';\n\nimport { Particle } from '../../Particle';\nimport { CallParams, CallServiceData, GenericCallServiceHandler, ResultCodes } from '../../commonTypes';\nimport { FluencePeer } from '../../FluencePeer';\n\nimport { aquaArgs2Ts, responseServiceValue2ts, returnType2Aqua, ts2aqua } from './conversions';\nimport { ArrowWithoutCallbacks, FunctionCallConstants, FunctionCallDef, NonArrowType } from './interface';\n\nexport interface ServiceDescription {\n    serviceId: string;\n    fnName: string;\n    handler: GenericCallServiceHandler;\n}\n\n/**\n * Creates a service which injects relay's peer id into aqua space\n */\nexport const injectRelayService = (def: FunctionCallDef, peer: FluencePeer) => {\n    return {\n        serviceId: def.names.getDataSrv,\n        fnName: def.names.relay,\n        handler: () => {\n            return {\n                retCode: ResultCodes.success,\n                result: peer.getStatus().relayPeerId,\n            };\n        },\n    };\n};\n\n/**\n * Creates a service which injects plain value into aqua space\n */\nexport const injectValueService = (serviceId: string, fnName: string, valueType: NonArrowType, value: any) => {\n    return {\n        serviceId: serviceId,\n        fnName: fnName,\n        handler: () => {\n            return {\n                retCode: ResultCodes.success,\n                result: ts2aqua(value, valueType),\n            };\n        },\n    };\n};\n\n/**\n *  Creates a service which is used to return value from aqua function into typescript space\n */\nexport const responseService = (def: FunctionCallDef, resolveCallback: Function) => {\n    return {\n        serviceId: def.names.responseSrv,\n        fnName: def.names.responseFnName,\n        handler: (req: CallServiceData) => {\n            const userFunctionReturn = responseServiceValue2ts(req, def.arrow);\n\n            setTimeout(() => {\n                resolveCallback(userFunctionReturn);\n            }, 0);\n\n            return {\n                retCode: ResultCodes.success,\n                result: {},\n            };\n        },\n    };\n};\n\n/**\n * Creates a service which is used to return errors from aqua function into typescript space\n */\nexport const errorHandlingService = (def: FunctionCallDef, rejectCallback: Function) => {\n    return {\n        serviceId: def.names.errorHandlingSrv,\n        fnName: def.names.errorFnName,\n        handler: (req: CallServiceData) => {\n            const [err, _] = req.args;\n            setTimeout(() => {\n                rejectCallback(err);\n            }, 0);\n            return {\n                retCode: ResultCodes.success,\n                result: {},\n            };\n        },\n    };\n};\n\n/**\n * Creates a service for user-defined service function handler\n */\nexport const userHandlerService = (\n    serviceId: string,\n    arrowType: [string, ArrowWithoutCallbacks],\n    userHandler: (...args: Array<unknown>) => Promise<unknown>,\n) => {\n    const [fnName, type] = arrowType;\n    return {\n        serviceId,\n        fnName,\n        handler: async (req: CallServiceData) => {\n            const args = [...aquaArgs2Ts(req, type), extractCallParams(req, type)];\n            const rawResult = await userHandler.apply(null, args);\n            const result = returnType2Aqua(rawResult, type);\n\n            return {\n                retCode: ResultCodes.success,\n                result: result,\n            };\n        },\n    };\n};\n\n/**\n * Converts argument of aqua function to a corresponding service.\n * For arguments of non-arrow types the resulting service injects the argument into aqua space.\n * For arguments of arrow types the resulting service calls the corresponding function.\n */\nexport const argToServiceDef = (\n    arg: any,\n    argName: string,\n    argType: NonArrowType | ArrowWithoutCallbacks,\n    names: FunctionCallConstants,\n): ServiceDescription => {\n    if (argType.tag === 'arrow') {\n        return userHandlerService(names.callbackSrv, [argName, argType], arg);\n    } else {\n        return injectValueService(names.getDataSrv, argName, arg, argType);\n    }\n};\n\n/**\n * Extracts call params from from call service data according to aqua type definition\n */\nconst extractCallParams = (req: CallServiceData, arrow: ArrowWithoutCallbacks): CallParams<any> => {\n    const names = match(arrow.domain)\n        .with({ tag: 'nil' }, () => {\n            return [] as string[];\n        })\n        .with({ tag: 'labeledProduct' }, (x) => {\n            return Object.keys(x.fields);\n        })\n        .with({ tag: 'unlabeledProduct' }, (x) => {\n            return x.items.map((_, index) => 'arg' + index);\n        })\n        .exhaustive();\n\n    const tetraplets: Record<string, SecurityTetraplet[]> = {};\n    for (let i = 0; i < req.args.length; i++) {\n        if (names[i]) {\n            tetraplets[names[i]] = req.tetraplets[i];\n        }\n    }\n\n    const callParams = {\n        ...req.particleContext,\n        tetraplets,\n    };\n\n    return callParams;\n};\n\nexport const registerParticleScopeService = (peer: FluencePeer, particle: Particle, service: ServiceDescription) => {\n    peer.internals.regHandler.forParticle(particle.id, service.serviceId, service.fnName, service.handler);\n};\n\nexport const registerGlobalService = (peer: FluencePeer, service: ServiceDescription) => {\n    peer.internals.regHandler.common(service.serviceId, service.fnName, service.handler);\n};\n"]}
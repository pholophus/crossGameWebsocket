import { FluencePeer } from '../../index';
export { FluencePeer } from '../FluencePeer';
export { CallParams } from '../commonTypes';
/**
 * Represents the Aqua Option type
 */
declare type OptionalType = {
    /**
     * Type descriptor. Used for pattern-matching
     */
    tag: 'optional';
};
/**
 * Represents the void type for functions and callbacks with no return value
 */
declare type VoidType = {
    /**
     * Type descriptor. Used for pattern-matching
     */
    tag: 'void';
};
/**
 * Represents all types other than Optional, Void, Callback and MultiReturn
 */
declare type PrimitiveType = {
    /**
     * Type descriptor. Used for pattern-matching
     */
    tag: 'primitive';
};
/**
 * Represents callbacks used in Aqua function arguments (`func` instruction)
 */
declare type CallbackType = {
    /**
     * Type descriptor. Used for pattern-matching
     */
    tag: 'callback';
    /**
     * Callback definition
     */
    callback: CallbackDef<OptionalType | PrimitiveType, VoidType | OptionalType | PrimitiveType>;
};
/**
 * Represents the return type for functions which return multiple values
 */
declare type MultiReturnType = {
    /**
     * Type descriptor. Used for pattern-matching
     */
    tag: 'multiReturn';
    /**
     * The description of types of the return values: Array of either primitive or optional types
     */
    returnItems: Array<OptionalType | PrimitiveType>;
};
interface ArgDef<ArgType> {
    /**
     * The name of the argument in Aqua language
     */
    name: string;
    /**
     * The type of the argument
     */
    argType: ArgType;
}
interface CallbackDef<ArgType, ReturnType> {
    /**
     * Callback argument definitions: the list of ArgDefs
     */
    argDefs: Array<ArgDef<ArgType>>;
    /**
     * Definition of the return type of callback
     */
    returnType: ReturnType;
}
interface FunctionBodyDef extends CallbackDef<OptionalType | PrimitiveType, VoidType | OptionalType | PrimitiveType> {
    /**
     * The name of the function in Aqua language
     */
    functionName: string;
}
/**
 * Definition of function (`func` instruction) generated by the Aqua compiler
 */
interface FunctionCallDef extends CallbackDef<OptionalType | PrimitiveType | CallbackType, VoidType | OptionalType | PrimitiveType | MultiReturnType> {
    /**
     * The name of the function in Aqua language
     */
    functionName: string;
    /**
     * Names of the different entities used in generated air script
     */
    names: {
        /**
         * The name of the relay variable
         */
        relay: string;
        /**
         * The name of the serviceId used load variables at the beginning of the script
         */
        getDataSrv: string;
        /**
         * The name of serviceId is used to execute callbacks for the current particle
         */
        callbackSrv: string;
        /**
         * The name of the serviceId which is called to propagate return value to the generated function caller
         */
        responseSrv: string;
        /**
         * The name of the functionName which is called to propagate return value to the generated function caller
         */
        responseFnName: string;
        /**
         * The name of the serviceId which is called to report errors to the generated function caller
         */
        errorHandlingSrv: string;
        /**
         * The name of the functionName which is called to report errors to the generated function caller
         */
        errorFnName: string;
    };
}
/**
 * Definition of service registration function (`service` instruction) generated by the Aqua compiler
 */
interface ServiceDef {
    /**
     * Default service id. If the service has no default id the value should be undefined
     */
    defaultServiceId?: string;
    /**
     * List of functions which the service consists of
     */
    functions: Array<FunctionBodyDef>;
}
/**
 * Options to configure Aqua function execution
 */
export interface FnConfig {
    /**
     * Sets the TTL (time to live) for particle responsible for the function execution
     * If the option is not set the default TTL from FluencePeer config is used
     */
    ttl?: number;
}
/**
 * Convenience function to support Aqua `func` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param rawFnArgs - raw arguments passed by user to the generated function
 * @param def - function definition generated by the Aqua compiler
 * @param script - air script with function execution logic generated by the Aqua compiler
 */
export declare function callFunction(rawFnArgs: Array<any>, def: FunctionCallDef, script: string): Promise<unknown>;
/**
 * Convenience function to support Aqua `service` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param args - raw arguments passed by user to the generated function
 * @param def - service definition generated by the Aqua compiler
 */
export declare function registerService(args: any[], def: ServiceDef): void;
export declare const forTests: {
    extractFunctionArgs: (args: any[], numberOfExpectedArgs: number) => {
        peer: FluencePeer;
        config?: FnConfig | undefined;
        args: any[];
    };
};
//# sourceMappingURL=v2.d.ts.map
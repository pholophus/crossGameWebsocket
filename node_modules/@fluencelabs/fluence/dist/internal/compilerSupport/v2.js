"use strict";
/*
 * Copyright 2021 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forTests = exports.registerService = exports.callFunction = exports.FluencePeer = void 0;
var ts_pattern_1 = require("ts-pattern");
var index_1 = require("../../index");
var commonTypes_1 = require("../commonTypes");
var FluencePeer_1 = require("../FluencePeer");
Object.defineProperty(exports, "FluencePeer", { enumerable: true, get: function () { return FluencePeer_1.FluencePeer; } });
/**
 * Convenience function to support Aqua `func` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param rawFnArgs - raw arguments passed by user to the generated function
 * @param def - function definition generated by the Aqua compiler
 * @param script - air script with function execution logic generated by the Aqua compiler
 */
function callFunction(rawFnArgs, def, script) {
    var _this = this;
    var _a = extractFunctionArgs(rawFnArgs, def.argDefs.length), args = _a.args, peer = _a.peer, config = _a.config;
    if (args.length !== def.argDefs.length) {
        throw new Error('Incorrect number of arguments. Expecting ${def.argDefs.length}');
    }
    var promise = new Promise(function (resolve, reject) {
        var particle = peer.internals.createNewParticle(script, config === null || config === void 0 ? void 0 : config.ttl);
        if (particle instanceof Error) {
            return reject(particle.message);
        }
        var _loop_1 = function (i) {
            var argDef = def.argDefs[i];
            var arg = args[i];
            var _a = __read((0, ts_pattern_1.match)(argDef.argType)
                // for callback arguments we are registering particle-specific callback which executes the passed function
                .with({ tag: 'callback' }, function (callbackDef) {
                var fn = function (req) { return __awaiter(_this, void 0, void 0, function () {
                    var args, result, res;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                args = convertArgsFromReqToUserCall(req, callbackDef.callback.argDefs);
                                return [4 /*yield*/, arg.apply(null, args)];
                            case 1:
                                result = _a.sent();
                                switch (callbackDef.callback.returnType.tag) {
                                    case 'void':
                                        res = {};
                                        break;
                                    case 'primitive':
                                        res = result;
                                        break;
                                    case 'optional':
                                        res = tsToAquaOpt(result);
                                        break;
                                }
                                return [2 /*return*/, {
                                        retCode: commonTypes_1.ResultCodes.success,
                                        result: res,
                                    }];
                        }
                    });
                }); };
                return [def.names.callbackSrv, argDef.name, fn];
            })
                // for optional types we are converting value to array representation in air
                .with({ tag: 'optional' }, function () {
                var fn = function (req) {
                    // arg is optional at this point
                    var res = tsToAquaOpt(arg);
                    return {
                        retCode: commonTypes_1.ResultCodes.success,
                        result: res,
                    };
                };
                return [def.names.getDataSrv, argDef.name, fn];
            })
                // for primitive types wre are simply passing the value
                .with({ tag: 'primitive' }, function () {
                // arg is primitive at this point
                var fn = function (req) { return ({
                    retCode: commonTypes_1.ResultCodes.success,
                    result: arg,
                }); };
                return [def.names.getDataSrv, argDef.name, fn];
            })
                .exhaustive(), 3), serviceId = _a[0], fnName = _a[1], cb = _a[2];
            // registering handlers for every argument of the function
            peer.internals.regHandler.forParticle(particle.id, serviceId, fnName, cb);
        };
        for (var i = 0; i < def.argDefs.length; i++) {
            _loop_1(i);
        }
        // registering handler for function response
        peer.internals.regHandler.forParticle(particle.id, def.names.responseSrv, def.names.responseFnName, function (req) {
            var userFunctionReturn = (0, ts_pattern_1.match)(def.returnType)
                .with({ tag: 'primitive' }, function () { return req.args[0]; })
                .with({ tag: 'optional' }, function () { return aquaOptToTs(req.args[0]); })
                .with({ tag: 'void' }, function () { return undefined; })
                .with({ tag: 'multiReturn' }, function (mr) {
                return mr.returnItems.map(function (x, index) {
                    return (0, ts_pattern_1.match)(x)
                        .with({ tag: 'optional' }, function () { return aquaOptToTs(req.args[index]); })
                        .with({ tag: 'primitive' }, function () { return req.args[index]; })
                        .exhaustive();
                });
            })
                .exhaustive();
            setTimeout(function () {
                resolve(userFunctionReturn);
            }, 0);
            return {
                retCode: commonTypes_1.ResultCodes.success,
                result: {},
            };
        });
        // registering handler for injecting relay variable
        peer.internals.regHandler.forParticle(particle.id, def.names.getDataSrv, def.names.relay, function (req) {
            return {
                retCode: commonTypes_1.ResultCodes.success,
                result: peer.getStatus().relayPeerId,
            };
        });
        // registering handler for error reporting
        peer.internals.regHandler.forParticle(particle.id, def.names.errorHandlingSrv, def.names.errorFnName, function (req) {
            var _a = __read(req.args, 2), err = _a[0], _ = _a[1];
            setTimeout(function () {
                reject(err);
            }, 0);
            return {
                retCode: commonTypes_1.ResultCodes.success,
                result: {},
            };
        });
        peer.internals.initiateParticle(particle, function (stage) {
            // If function is void, then it's completed when one of the two conditions is met:
            //  1. The particle is sent to the network (state 'sent')
            //  2. All CallRequests are executed, e.g., all variable loading and local function calls are completed (state 'localWorkDone')
            if (def.returnType.tag === 'void' && (stage.stage === 'sent' || stage.stage === 'localWorkDone')) {
                resolve(undefined);
            }
            if (stage.stage === 'sendingError') {
                reject("Could not send particle for ".concat(def.functionName, ": not connected  (particle id: ").concat(particle.id, ")"));
            }
            if (stage.stage === 'expired') {
                reject("Request timed out after ".concat(particle.ttl, " for ").concat(def.functionName, " (particle id: ").concat(particle.id, ")"));
            }
            if (stage.stage === 'interpreterError') {
                reject("Script interpretation failed for ".concat(def.functionName, ": ").concat(stage.errorMessage, "  (particle id: ").concat(particle.id, ")"));
            }
        });
    });
    return promise;
}
exports.callFunction = callFunction;
/**
 * Convenience function to support Aqua `service` generation backend
 * The compiler only need to generate a call the function and provide the corresponding definitions and the air script
 *
 * @param args - raw arguments passed by user to the generated function
 * @param def - service definition generated by the Aqua compiler
 */
function registerService(args, def) {
    var e_1, _a;
    var _this = this;
    var _b = extractRegisterServiceArgs(args, def.defaultServiceId), peer = _b.peer, service = _b.service, serviceId = _b.serviceId;
    if (!peer.getStatus().isInitialized) {
        throw new Error('Could not register the service because the peer is not initialized. Are you passing the wrong peer to the register function?');
    }
    // Checking for missing keys
    var requiredKeys = def.functions.map(function (x) { return x.functionName; });
    var incorrectServiceDefinitions = requiredKeys.filter(function (f) { return !(f in service); });
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service ".concat(serviceId, ": missing functions: ") +
            incorrectServiceDefinitions.map(function (d) { return "'" + d + "'"; }).join(', '));
    }
    var _loop_2 = function (singleFunction) {
        // The function has type of (arg1, arg2, arg3, ... , callParams) => CallServiceResultType | void
        // Account for the fact that user service might be defined as a class - .bind(...)
        var userDefinedHandler = service[singleFunction.functionName].bind(service);
        peer.internals.regHandler.common(serviceId, singleFunction.functionName, function (req) { return __awaiter(_this, void 0, void 0, function () {
            var args, rawResult, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        args = convertArgsFromReqToUserCall(req, singleFunction.argDefs);
                        return [4 /*yield*/, userDefinedHandler.apply(null, args)];
                    case 1:
                        rawResult = _a.sent();
                        result = (0, ts_pattern_1.match)(singleFunction.returnType)
                            .with({ tag: 'primitive' }, function () { return rawResult; })
                            .with({ tag: 'optional' }, function () { return tsToAquaOpt(rawResult); })
                            .with({ tag: 'void' }, function () { return ({}); })
                            .exhaustive();
                        return [2 /*return*/, {
                                retCode: commonTypes_1.ResultCodes.success,
                                result: result,
                            }];
                }
            });
        }); });
    };
    try {
        for (var _c = __values(def.functions), _d = _c.next(); !_d.done; _d = _c.next()) {
            var singleFunction = _d.value;
            _loop_2(singleFunction);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.registerService = registerService;
/**
 * Converts argument from ts representation (value | null) to air representation ([value] | [])
 */
var tsToAquaOpt = function (arg) {
    return arg === null || arg === undefined ? [] : [arg];
};
/**
 * Converts argument from air representation ([value] | []) to ts representation (value | null)
 */
var aquaOptToTs = function (opt) {
    return opt.length === 0 ? null : opt[0];
};
/**
 * Converts raw arguments which may contain optional types from air representation to ts representation
 */
var convertArgsFromReqToUserCall = function (req, argDefs) {
    if (req.args.length !== argDefs.length) {
        throwForReq(req, "incorrect number of arguments, expected ".concat(argDefs.length));
    }
    var argsAccountedForOptional = req.args.map(function (x, index) {
        return (0, ts_pattern_1.match)(argDefs[index].argType)
            .with({ tag: 'optional' }, function () { return aquaOptToTs(x); })
            .with({ tag: 'primitive' }, function () { return x; })
            .exhaustive();
    });
    return __spreadArray(__spreadArray([], __read(argsAccountedForOptional), false), [extractCallParams(req, argDefs)], false);
};
/**
 * Extracts Call Params from CallServiceData and forms tetraplets according to generated function definition
 */
var extractCallParams = function (req, argDefs) {
    var tetraplets = {};
    for (var i = 0; i < req.args.length; i++) {
        if (argDefs[i]) {
            tetraplets[argDefs[i].name] = req.tetraplets[i];
        }
    }
    var callParams = __assign(__assign({}, req.particleContext), { tetraplets: tetraplets });
    return callParams;
};
/**
 * Arguments could be passed in one these configurations:
 * [...actualArgs]
 * [peer, ...actualArgs]
 * [...actualArgs, config]
 * [peer, ...actualArgs, config]
 *
 * This function select the appropriate configuration and returns
 * arguments in a structured way of: { peer, config, args }
 */
var extractFunctionArgs = function (args, numberOfExpectedArgs) {
    var peer;
    var structuredArgs;
    var config;
    if (index_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
        structuredArgs = args.slice(1, numberOfExpectedArgs + 1);
        config = args[numberOfExpectedArgs + 1];
    }
    else {
        peer = index_1.Fluence.getPeer();
        structuredArgs = args.slice(0, numberOfExpectedArgs);
        config = args[numberOfExpectedArgs];
    }
    return {
        peer: peer,
        config: config,
        args: structuredArgs,
    };
};
/**
 * Arguments could be passed in one these configurations:
 * [serviceObject]
 * [peer, serviceObject]
 * [defaultId, serviceObject]
 * [peer, defaultId, serviceObject]
 *
 * Where serviceObject is the raw object with function definitions passed by user
 *
 * This function select the appropriate configuration and returns
 * arguments in a structured way of: { peer, serviceId, service }
 */
var extractRegisterServiceArgs = function (args, defaultServiceId) {
    var peer;
    var serviceId;
    var service;
    if (index_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = index_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = defaultServiceId;
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!index_1.FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    return {
        peer: peer,
        serviceId: serviceId,
        service: service,
    };
};
function throwForReq(req, message) {
    throw new Error("".concat(message, ", serviceId='").concat(req.serviceId, "' fnName='").concat(req.fnName, "' args='").concat(req.args, "'"));
}
exports.forTests = {
    extractFunctionArgs: extractFunctionArgs,
};
//# sourceMappingURL=v2.js.map
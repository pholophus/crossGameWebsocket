{"version":3,"file":"v2.js","sourceRoot":"","sources":["../../../src/internal/compilerSupport/v2.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SecurityTetraplet } from '@fluencelabs/avm';\nimport { match } from 'ts-pattern';\nimport { CallParams, Fluence, FluencePeer } from '../../index';\nimport { CallServiceData, GenericCallServiceHandler, CallServiceResult, ResultCodes } from '../commonTypes';\nimport { Particle } from '../Particle';\n\nexport { FluencePeer } from '../FluencePeer';\nexport { CallParams } from '../commonTypes';\n\n/**\n * Represents the Aqua Option type\n */\ntype OptionalType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'optional';\n};\n\n/**\n * Represents the void type for functions and callbacks with no return value\n */\ntype VoidType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'void';\n};\n\n/**\n * Represents all types other than Optional, Void, Callback and MultiReturn\n */\ntype PrimitiveType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'primitive';\n};\n\n/**\n * Represents callbacks used in Aqua function arguments (`func` instruction)\n */\ntype CallbackType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'callback';\n\n    /**\n     * Callback definition\n     */\n    callback: CallbackDef<OptionalType | PrimitiveType, VoidType | OptionalType | PrimitiveType>;\n};\n\n/**\n * Represents the return type for functions which return multiple values\n */\ntype MultiReturnType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'multiReturn';\n\n    /**\n     * The description of types of the return values: Array of either primitive or optional types\n     */\n    returnItems: Array<OptionalType | PrimitiveType>;\n};\n\ninterface ArgDef<ArgType> {\n    /**\n     * The name of the argument in Aqua language\n     */\n    name: string;\n\n    /**\n     * The type of the argument\n     */\n    argType: ArgType;\n}\n\ninterface CallbackDef<ArgType, ReturnType> {\n    /**\n     * Callback argument definitions: the list of ArgDefs\n     */\n    argDefs: Array<ArgDef<ArgType>>;\n\n    /**\n     * Definition of the return type of callback\n     */\n    returnType: ReturnType;\n}\n\ninterface FunctionBodyDef\n    extends CallbackDef<\n        // force new line\n        OptionalType | PrimitiveType,\n        VoidType | OptionalType | PrimitiveType\n    > {\n    /**\n     * The name of the function in Aqua language\n     */\n    functionName: string;\n}\n\n/**\n * Definition of function (`func` instruction) generated by the Aqua compiler\n */\ninterface FunctionCallDef\n    extends CallbackDef<\n        OptionalType | PrimitiveType | CallbackType,\n        VoidType | OptionalType | PrimitiveType | MultiReturnType\n    > {\n    /**\n     * The name of the function in Aqua language\n     */\n    functionName: string;\n\n    /**\n     * Names of the different entities used in generated air script\n     */\n    names: {\n        /**\n         * The name of the relay variable\n         */\n        relay: string;\n\n        /**\n         * The name of the serviceId used load variables at the beginning of the script\n         */\n        getDataSrv: string;\n\n        /**\n         * The name of serviceId is used to execute callbacks for the current particle\n         */\n        callbackSrv: string;\n\n        /**\n         * The name of the serviceId which is called to propagate return value to the generated function caller\n         */\n        responseSrv: string;\n\n        /**\n         * The name of the functionName which is called to propagate return value to the generated function caller\n         */\n        responseFnName: string;\n\n        /**\n         * The name of the serviceId which is called to report errors to the generated function caller\n         */\n        errorHandlingSrv: string;\n\n        /**\n         * The name of the functionName which is called to report errors to the generated function caller\n         */\n        errorFnName: string;\n    };\n}\n\n/**\n * Definition of service registration function (`service` instruction) generated by the Aqua compiler\n */\ninterface ServiceDef {\n    /**\n     * Default service id. If the service has no default id the value should be undefined\n     */\n    defaultServiceId?: string;\n\n    /**\n     * List of functions which the service consists of\n     */\n    functions: Array<FunctionBodyDef>;\n}\n\n/**\n * Options to configure Aqua function execution\n */\nexport interface FnConfig {\n    /**\n     * Sets the TTL (time to live) for particle responsible for the function execution\n     * If the option is not set the default TTL from FluencePeer config is used\n     */\n    ttl?: number;\n}\n\n/**\n * Convenience function to support Aqua `func` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param rawFnArgs - raw arguments passed by user to the generated function\n * @param def - function definition generated by the Aqua compiler\n * @param script - air script with function execution logic generated by the Aqua compiler\n */\nexport function callFunction(rawFnArgs: Array<any>, def: FunctionCallDef, script: string) {\n    const { args, peer, config } = extractFunctionArgs(rawFnArgs, def.argDefs.length);\n\n    if (args.length !== def.argDefs.length) {\n        throw new Error('Incorrect number of arguments. Expecting ${def.argDefs.length}');\n    }\n\n    const promise = new Promise((resolve, reject) => {\n        const particle = peer.internals.createNewParticle(script, config?.ttl);\n\n        if (particle instanceof Error) {\n            return reject(particle.message);\n        }\n\n        for (let i = 0; i < def.argDefs.length; i++) {\n            const argDef = def.argDefs[i];\n            const arg = args[i];\n\n            const [serviceId, fnName, cb] = match(argDef.argType)\n                // for callback arguments we are registering particle-specific callback which executes the passed function\n                .with({ tag: 'callback' }, (callbackDef) => {\n                    const fn = async (req: CallServiceData): Promise<CallServiceResult> => {\n                        const args = convertArgsFromReqToUserCall(req, callbackDef.callback.argDefs);\n                        // arg is function at this point\n                        const result = await arg.apply(null, args);\n                        let res;\n                        switch (callbackDef.callback.returnType.tag) {\n                            case 'void':\n                                res = {};\n                                break;\n                            case 'primitive':\n                                res = result;\n                                break;\n                            case 'optional':\n                                res = tsToAquaOpt(result);\n                                break;\n                        }\n                        return {\n                            retCode: ResultCodes.success,\n                            result: res,\n                        };\n                    };\n                    return [def.names.callbackSrv, argDef.name, fn] as const;\n                })\n                // for optional types we are converting value to array representation in air\n                .with({ tag: 'optional' }, () => {\n                    const fn = (req: CallServiceData): CallServiceResult => {\n                        // arg is optional at this point\n                        const res = tsToAquaOpt(arg);\n                        return {\n                            retCode: ResultCodes.success,\n                            result: res,\n                        };\n                    };\n                    return [def.names.getDataSrv, argDef.name, fn] as const;\n                })\n                // for primitive types wre are simply passing the value\n                .with({ tag: 'primitive' }, () => {\n                    // arg is primitive at this point\n                    const fn = (req: CallServiceData): CallServiceResult => ({\n                        retCode: ResultCodes.success,\n                        result: arg,\n                    });\n                    return [def.names.getDataSrv, argDef.name, fn] as const;\n                })\n                .exhaustive();\n\n            // registering handlers for every argument of the function\n            peer.internals.regHandler.forParticle(particle.id, serviceId, fnName, cb);\n        }\n\n        // registering handler for function response\n        peer.internals.regHandler.forParticle(particle.id, def.names.responseSrv, def.names.responseFnName, (req) => {\n            const userFunctionReturn = match(def.returnType)\n                .with({ tag: 'primitive' }, () => req.args[0])\n                .with({ tag: 'optional' }, () => aquaOptToTs(req.args[0]))\n                .with({ tag: 'void' }, () => undefined)\n                .with({ tag: 'multiReturn' }, (mr) => {\n                    return mr.returnItems.map((x, index) => {\n                        return match(x)\n                            .with({ tag: 'optional' }, () => aquaOptToTs(req.args[index]))\n                            .with({ tag: 'primitive' }, () => req.args[index])\n                            .exhaustive();\n                    });\n                })\n                .exhaustive();\n\n            setTimeout(() => {\n                resolve(userFunctionReturn);\n            }, 0);\n\n            return {\n                retCode: ResultCodes.success,\n                result: {},\n            };\n        });\n\n        // registering handler for injecting relay variable\n        peer.internals.regHandler.forParticle(particle.id, def.names.getDataSrv, def.names.relay, (req) => {\n            return {\n                retCode: ResultCodes.success,\n                result: peer.getStatus().relayPeerId,\n            };\n        });\n\n        // registering handler for error reporting\n        peer.internals.regHandler.forParticle(particle.id, def.names.errorHandlingSrv, def.names.errorFnName, (req) => {\n            const [err, _] = req.args;\n            setTimeout(() => {\n                reject(err);\n            }, 0);\n            return {\n                retCode: ResultCodes.success,\n                result: {},\n            };\n        });\n\n        peer.internals.initiateParticle(particle, (stage) => {\n            // If function is void, then it's completed when one of the two conditions is met:\n            //  1. The particle is sent to the network (state 'sent')\n            //  2. All CallRequests are executed, e.g., all variable loading and local function calls are completed (state 'localWorkDone')\n            if (def.returnType.tag === 'void' && (stage.stage === 'sent' || stage.stage === 'localWorkDone')) {\n                resolve(undefined);\n            }\n\n            if (stage.stage === 'sendingError') {\n                reject(`Could not send particle for ${def.functionName}: not connected  (particle id: ${particle.id})`);\n            }\n\n            if (stage.stage === 'expired') {\n                reject(`Request timed out after ${particle.ttl} for ${def.functionName} (particle id: ${particle.id})`);\n            }\n\n            if (stage.stage === 'interpreterError') {\n                reject(\n                    `Script interpretation failed for ${def.functionName}: ${stage.errorMessage}  (particle id: ${particle.id})`,\n                );\n            }\n        });\n    });\n\n    return promise;\n}\n\n/**\n * Convenience function to support Aqua `service` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param args - raw arguments passed by user to the generated function\n * @param def - service definition generated by the Aqua compiler\n */\nexport function registerService(args: any[], def: ServiceDef) {\n    const { peer, service, serviceId } = extractRegisterServiceArgs(args, def.defaultServiceId);\n\n    if (!peer.getStatus().isInitialized) {\n        throw new Error(\n            'Could not register the service because the peer is not initialized. Are you passing the wrong peer to the register function?',\n        );\n    }\n\n    // Checking for missing keys\n    const requiredKeys = def.functions.map((x) => x.functionName);\n    const incorrectServiceDefinitions = requiredKeys.filter((f) => !(f in service));\n    if (!!incorrectServiceDefinitions.length) {\n        throw new Error(\n            `Error registering service ${serviceId}: missing functions: ` +\n                incorrectServiceDefinitions.map((d) => \"'\" + d + \"'\").join(', '),\n        );\n    }\n\n    for (let singleFunction of def.functions) {\n        // The function has type of (arg1, arg2, arg3, ... , callParams) => CallServiceResultType | void\n        // Account for the fact that user service might be defined as a class - .bind(...)\n        const userDefinedHandler = service[singleFunction.functionName].bind(service);\n\n        peer.internals.regHandler.common(serviceId, singleFunction.functionName, async (req) => {\n            const args = convertArgsFromReqToUserCall(req, singleFunction.argDefs);\n            const rawResult = await userDefinedHandler.apply(null, args);\n            const result = match(singleFunction.returnType)\n                .with({ tag: 'primitive' }, () => rawResult)\n                .with({ tag: 'optional' }, () => tsToAquaOpt(rawResult))\n                .with({ tag: 'void' }, () => ({}))\n                .exhaustive();\n\n            return {\n                retCode: ResultCodes.success,\n                result: result,\n            };\n        });\n    }\n}\n\n/**\n * Converts argument from ts representation (value | null) to air representation ([value] | [])\n */\nconst tsToAquaOpt = (arg: unknown | null): any => {\n    return arg === null || arg === undefined ? [] : [arg];\n};\n\n/**\n * Converts argument from air representation ([value] | []) to ts representation (value | null)\n */\nconst aquaOptToTs = (opt: Array<unknown>) => {\n    return opt.length === 0 ? null : opt[0];\n};\n\n/**\n * Converts raw arguments which may contain optional types from air representation to ts representation\n */\nconst convertArgsFromReqToUserCall = (req: CallServiceData, argDefs: Array<ArgDef<OptionalType | PrimitiveType>>) => {\n    if (req.args.length !== argDefs.length) {\n        throwForReq(req, `incorrect number of arguments, expected ${argDefs.length}`);\n    }\n\n    const argsAccountedForOptional = req.args.map((x, index) => {\n        return match(argDefs[index].argType)\n            .with({ tag: 'optional' }, () => aquaOptToTs(x))\n            .with({ tag: 'primitive' }, () => x)\n            .exhaustive();\n    });\n\n    return [...argsAccountedForOptional, extractCallParams(req, argDefs)];\n};\n\n/**\n * Extracts Call Params from CallServiceData and forms tetraplets according to generated function definition\n */\nconst extractCallParams = (\n    req: CallServiceData,\n    argDefs: Array<ArgDef<OptionalType | PrimitiveType>>,\n): CallParams<any> => {\n    let tetraplets: { [key in string]: SecurityTetraplet[] } = {};\n    for (let i = 0; i < req.args.length; i++) {\n        if (argDefs[i]) {\n            tetraplets[argDefs[i].name] = req.tetraplets[i];\n        }\n    }\n\n    const callParams = {\n        ...req.particleContext,\n        tetraplets,\n    };\n\n    return callParams;\n};\n\n/**\n * Arguments could be passed in one these configurations:\n * [...actualArgs]\n * [peer, ...actualArgs]\n * [...actualArgs, config]\n * [peer, ...actualArgs, config]\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, config, args }\n */\nconst extractFunctionArgs = (\n    args: any[],\n    numberOfExpectedArgs: number,\n): {\n    peer: FluencePeer;\n    config?: FnConfig;\n    args: any[];\n} => {\n    let peer: FluencePeer;\n    let structuredArgs: any[];\n    let config: any;\n    if (FluencePeer.isInstance(args[0])) {\n        peer = args[0];\n        structuredArgs = args.slice(1, numberOfExpectedArgs + 1);\n        config = args[numberOfExpectedArgs + 1];\n    } else {\n        peer = Fluence.getPeer();\n        structuredArgs = args.slice(0, numberOfExpectedArgs);\n        config = args[numberOfExpectedArgs];\n    }\n\n    return {\n        peer: peer,\n        config: config,\n        args: structuredArgs,\n    };\n};\n\n/**\n * Arguments could be passed in one these configurations:\n * [serviceObject]\n * [peer, serviceObject]\n * [defaultId, serviceObject]\n * [peer, defaultId, serviceObject]\n *\n * Where serviceObject is the raw object with function definitions passed by user\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, serviceId, service }\n */\nconst extractRegisterServiceArgs = (\n    args: any[],\n    defaultServiceId?: string,\n): { peer: FluencePeer; serviceId: string; service: any } => {\n    let peer: FluencePeer;\n    let serviceId: any;\n    let service: any;\n    if (FluencePeer.isInstance(args[0])) {\n        peer = args[0];\n    } else {\n        peer = Fluence.getPeer();\n    }\n\n    if (typeof args[0] === 'string') {\n        serviceId = args[0];\n    } else if (typeof args[1] === 'string') {\n        serviceId = args[1];\n    } else {\n        serviceId = defaultServiceId;\n    }\n\n    // Figuring out which overload is the service.\n    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def\n    // If the first argument is peer, we are checking further. The second argument might either be\n    // an object, that it must be the service object\n    // or a string, which is the service id. In that case the service is the third argument\n    if (!FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {\n        service = args[0];\n    } else if (typeof args[1] === 'object') {\n        service = args[1];\n    } else {\n        service = args[2];\n    }\n\n    return {\n        peer: peer,\n        serviceId: serviceId,\n        service: service,\n    };\n};\n\nfunction throwForReq(req: CallServiceData, message: string) {\n    throw new Error(`${message}, serviceId='${req.serviceId}' fnName='${req.fnName}' args='${req.args}'`);\n}\n\nexport const forTests = {\n    extractFunctionArgs,\n};\n"]}
{"version":3,"file":"interface.js","sourceRoot":"","sources":["../../../../src/internal/compilerSupport/v3impl/interface.ts"],"names":[],"mappings":"","sourcesContent":["type SomeNonArrowTypes = ScalarType | OptionType | ArrayType | StructType | TopType | BottomType;\n\nexport type NonArrowType = SomeNonArrowTypes | ProductType<SomeNonArrowTypes>;\n\nexport type TopType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'topType';\n};\n\nexport type BottomType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'bottomType';\n};\n\nexport type OptionType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'option';\n\n    /**\n     * Underlying type of the option\n     */\n    type: NonArrowType;\n};\n\nexport type NilType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'nil';\n};\n\nexport type ArrayType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'array';\n\n    /**\n     * Type of array elements\n     */\n    type: NonArrowType;\n};\n\n/**\n * All possible scalar type names\n */\nexport type ScalarNames =\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'i8'\n    | 'i16'\n    | 'i32'\n    | 'i64'\n    | 'f32'\n    | 'f64'\n    | 'bool'\n    | 'string';\n\nexport type ScalarType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'scalar';\n\n    /**\n     * Name of the scalar type\n     */\n    name: ScalarNames;\n};\n\nexport type StructType = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'struct';\n\n    /**\n     * Struct name\n     */\n    name: string;\n\n    /**\n     * Struct fields\n     */\n    fields: { [key: string]: NonArrowType };\n};\n\nexport type LabeledProductType<T> =\n    | {\n          /**\n           * Type descriptor. Used for pattern-matching\n           */\n          tag: 'labeledProduct';\n\n          /**\n           * Labelled product fields\n           */\n          fields: { [key: string]: T };\n      }\n    | NilType;\n\nexport type UnlabeledProductType<T> =\n    | {\n          /**\n           * Type descriptor. Used for pattern-matching\n           */\n          tag: 'unlabeledProduct';\n\n          /**\n           * Items in unlabelled product\n           */\n          items: Array<T>;\n      }\n    | NilType;\n\nexport type ProductType<T> = UnlabeledProductType<T> | LabeledProductType<T>;\n\n/**\n * ArrowType is a profunctor pointing its domain to codomain.\n * Profunctor means variance: Arrow is contravariant on domain, and variant on codomain.\n */\nexport type ArrowType<T> = {\n    /**\n     * Type descriptor. Used for pattern-matching\n     */\n    tag: 'arrow';\n\n    /**\n     * Where this Arrow is defined\n     */\n    domain: ProductType<T>;\n\n    /**\n     * Where this Arrow points to\n     */\n    codomain: UnlabeledProductType<NonArrowType> | NilType;\n};\n\n/**\n * Arrow which domain contains only non-arrow types\n */\nexport type ArrowWithoutCallbacks = ArrowType<NonArrowType>;\n\n/**\n * Arrow which domain does can contain both non-arrow types and arrows (which themselves cannot contain arrows)\n */\nexport type ArrowWithCallbacks = ArrowType<NonArrowType | ArrowWithoutCallbacks>;\n\nexport interface FunctionCallConstants {\n    /**\n     * The name of the relay variable\n     */\n    relay: string;\n\n    /**\n     * The name of the serviceId used load variables at the beginning of the script\n     */\n    getDataSrv: string;\n\n    /**\n     * The name of serviceId is used to execute callbacks for the current particle\n     */\n    callbackSrv: string;\n\n    /**\n     * The name of the serviceId which is called to propagate return value to the generated function caller\n     */\n    responseSrv: string;\n\n    /**\n     * The name of the functionName which is called to propagate return value to the generated function caller\n     */\n    responseFnName: string;\n\n    /**\n     * The name of the serviceId which is called to report errors to the generated function caller\n     */\n    errorHandlingSrv: string;\n\n    /**\n     * The name of the functionName which is called to report errors to the generated function caller\n     */\n    errorFnName: string;\n}\n\n/**\n * Definition of function (`func` instruction) generated by the Aqua compiler\n */\nexport interface FunctionCallDef {\n    /**\n     * The name of the function in Aqua language\n     */\n    functionName: string;\n\n    /**\n     * Underlying arrow which represents function in aqua\n     */\n    arrow: ArrowWithCallbacks;\n\n    /**\n     * Names of the different entities used in generated air script\n     */\n    names: FunctionCallConstants;\n}\n\n/**\n * Definition of service registration function (`service` instruction) generated by the Aqua compiler\n */\nexport interface ServiceDef {\n    /**\n     * Default service id. If the service has no default id the value should be undefined\n     */\n    defaultServiceId?: string;\n\n    /**\n     * List of functions which the service consists of\n     */\n    functions: LabeledProductType<ArrowWithoutCallbacks>;\n}\n\n/**\n * Options to configure Aqua function execution\n */\nexport interface FnConfig {\n    /**\n     * Sets the TTL (time to live) for particle responsible for the function execution\n     * If the option is not set the default TTL from FluencePeer config is used\n     */\n    ttl?: number;\n}\n"]}